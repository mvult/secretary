// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: todos.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTodo = `-- name: CreateTodo :one
INSERT INTO todo (
  name,
  "desc",
  status,
  user_id,
  created_at_recording_id,
  updated_at_recording_id
) VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, name, "desc", status, user_id, created_at_recording_id, updated_at_recording_id
`

type CreateTodoParams struct {
	Name                 string
	Desc                 pgtype.Text
	Status               pgtype.Text
	UserID               pgtype.Int4
	CreatedAtRecordingID pgtype.Int4
	UpdatedAtRecordingID pgtype.Int4
}

func (q *Queries) CreateTodo(ctx context.Context, arg CreateTodoParams) (Todo, error) {
	row := q.db.QueryRow(ctx, createTodo,
		arg.Name,
		arg.Desc,
		arg.Status,
		arg.UserID,
		arg.CreatedAtRecordingID,
		arg.UpdatedAtRecordingID,
	)
	var i Todo
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Desc,
		&i.Status,
		&i.UserID,
		&i.CreatedAtRecordingID,
		&i.UpdatedAtRecordingID,
	)
	return i, err
}

const createTodoHistory = `-- name: CreateTodoHistory :exec
INSERT INTO todo_history (
  todo_id,
  actor_user_id,
  change_type,
  name,
  "desc",
  status,
  user_id,
  created_at_recording_id,
  updated_at_recording_id
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
`

type CreateTodoHistoryParams struct {
	TodoID               int32
	ActorUserID          pgtype.Int4
	ChangeType           string
	Name                 pgtype.Text
	Desc                 pgtype.Text
	Status               pgtype.Text
	UserID               pgtype.Int4
	CreatedAtRecordingID pgtype.Int4
	UpdatedAtRecordingID pgtype.Int4
}

func (q *Queries) CreateTodoHistory(ctx context.Context, arg CreateTodoHistoryParams) error {
	_, err := q.db.Exec(ctx, createTodoHistory,
		arg.TodoID,
		arg.ActorUserID,
		arg.ChangeType,
		arg.Name,
		arg.Desc,
		arg.Status,
		arg.UserID,
		arg.CreatedAtRecordingID,
		arg.UpdatedAtRecordingID,
	)
	return err
}

const deleteTodo = `-- name: DeleteTodo :exec
DELETE FROM todo WHERE id = $1
`

func (q *Queries) DeleteTodo(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteTodo, id)
	return err
}

const getTodo = `-- name: GetTodo :one
SELECT
  t.id,
  t.name,
  t."desc",
  t.status,
  t.user_id,
  t.created_at_recording_id,
  t.updated_at_recording_id,
  r.name as recording_name,
  r.created_at as recording_date
FROM todo t
LEFT JOIN recording r ON t.created_at_recording_id = r.id
WHERE t.id = $1
`

type GetTodoRow struct {
	ID                   int32
	Name                 string
	Desc                 pgtype.Text
	Status               pgtype.Text
	UserID               pgtype.Int4
	CreatedAtRecordingID pgtype.Int4
	UpdatedAtRecordingID pgtype.Int4
	RecordingName        pgtype.Text
	RecordingDate        pgtype.Timestamptz
}

func (q *Queries) GetTodo(ctx context.Context, id int32) (GetTodoRow, error) {
	row := q.db.QueryRow(ctx, getTodo, id)
	var i GetTodoRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Desc,
		&i.Status,
		&i.UserID,
		&i.CreatedAtRecordingID,
		&i.UpdatedAtRecordingID,
		&i.RecordingName,
		&i.RecordingDate,
	)
	return i, err
}

const listTodoHistory = `-- name: ListTodoHistory :many
SELECT
  h.id,
  h.todo_id,
  h.actor_user_id,
  h.change_type,
  h.name,
  h."desc",
  h.status,
  h.user_id,
  h.created_at_recording_id,
  h.updated_at_recording_id,
  h.changed_at
FROM todo_history h
WHERE h.todo_id = $1
ORDER BY h.changed_at DESC
`

func (q *Queries) ListTodoHistory(ctx context.Context, todoID int32) ([]TodoHistory, error) {
	rows, err := q.db.Query(ctx, listTodoHistory, todoID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TodoHistory
	for rows.Next() {
		var i TodoHistory
		if err := rows.Scan(
			&i.ID,
			&i.TodoID,
			&i.ActorUserID,
			&i.ChangeType,
			&i.Name,
			&i.Desc,
			&i.Status,
			&i.UserID,
			&i.CreatedAtRecordingID,
			&i.UpdatedAtRecordingID,
			&i.ChangedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTodosByRecording = `-- name: ListTodosByRecording :many
SELECT
  t.id,
  t.name,
  t."desc",
  t.status,
  t.user_id,
  t.created_at_recording_id,
  t.updated_at_recording_id,
  r.name as recording_name,
  r.created_at as recording_date
FROM todo t
LEFT JOIN recording r ON t.created_at_recording_id = r.id
WHERE t.created_at_recording_id = $1
ORDER BY t.id DESC
`

type ListTodosByRecordingRow struct {
	ID                   int32
	Name                 string
	Desc                 pgtype.Text
	Status               pgtype.Text
	UserID               pgtype.Int4
	CreatedAtRecordingID pgtype.Int4
	UpdatedAtRecordingID pgtype.Int4
	RecordingName        pgtype.Text
	RecordingDate        pgtype.Timestamptz
}

func (q *Queries) ListTodosByRecording(ctx context.Context, createdAtRecordingID pgtype.Int4) ([]ListTodosByRecordingRow, error) {
	rows, err := q.db.Query(ctx, listTodosByRecording, createdAtRecordingID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTodosByRecordingRow
	for rows.Next() {
		var i ListTodosByRecordingRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Desc,
			&i.Status,
			&i.UserID,
			&i.CreatedAtRecordingID,
			&i.UpdatedAtRecordingID,
			&i.RecordingName,
			&i.RecordingDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTodosByUser = `-- name: ListTodosByUser :many
SELECT
  t.id,
  t.name,
  t."desc",
  t.status,
  t.user_id,
  t.created_at_recording_id,
  t.updated_at_recording_id,
  r.name as recording_name,
  r.created_at as recording_date
FROM todo t
LEFT JOIN recording r ON t.created_at_recording_id = r.id
WHERE t.user_id = $1
ORDER BY t.id DESC
`

type ListTodosByUserRow struct {
	ID                   int32
	Name                 string
	Desc                 pgtype.Text
	Status               pgtype.Text
	UserID               pgtype.Int4
	CreatedAtRecordingID pgtype.Int4
	UpdatedAtRecordingID pgtype.Int4
	RecordingName        pgtype.Text
	RecordingDate        pgtype.Timestamptz
}

func (q *Queries) ListTodosByUser(ctx context.Context, userID pgtype.Int4) ([]ListTodosByUserRow, error) {
	rows, err := q.db.Query(ctx, listTodosByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTodosByUserRow
	for rows.Next() {
		var i ListTodosByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Desc,
			&i.Status,
			&i.UserID,
			&i.CreatedAtRecordingID,
			&i.UpdatedAtRecordingID,
			&i.RecordingName,
			&i.RecordingDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTodo = `-- name: UpdateTodo :one
UPDATE todo
SET
  name = $2,
  "desc" = $3,
  status = $4,
  user_id = $5,
  updated_at_recording_id = $6
WHERE id = $1
RETURNING id, name, "desc", status, user_id, created_at_recording_id, updated_at_recording_id
`

type UpdateTodoParams struct {
	ID                   int32
	Name                 string
	Desc                 pgtype.Text
	Status               pgtype.Text
	UserID               pgtype.Int4
	UpdatedAtRecordingID pgtype.Int4
}

func (q *Queries) UpdateTodo(ctx context.Context, arg UpdateTodoParams) (Todo, error) {
	row := q.db.QueryRow(ctx, updateTodo,
		arg.ID,
		arg.Name,
		arg.Desc,
		arg.Status,
		arg.UserID,
		arg.UpdatedAtRecordingID,
	)
	var i Todo
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Desc,
		&i.Status,
		&i.UserID,
		&i.CreatedAtRecordingID,
		&i.UpdatedAtRecordingID,
	)
	return i, err
}
